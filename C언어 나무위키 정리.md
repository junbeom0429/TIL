# C언어 나무위키 정리
---
지원되는 기능이 적고 문법이 간단하다. 함수의 개수로 치면 고작 150개 근처.  
하지만 기능이 적다고 쉬운 건 아니다. 기본 라이브러리에서 지원하지 않는 기능은 결국 프로그래머가  
직접 구현해서 써야 한다. **고로 기능의 구현이나 최적화에 관한 많은 트릭이 존재하고 이것을얼마나 많이 알고있는가가 사실 C언어의 핵심이다.**  

---
C언어 사용 시에 어려움을 느끼기 쉬운 부분들
---
* 느슨한 타입검사 : 서로 다른 종류의 포인터끼리 대입조차 가능  
* 인덱스가 배열 범위를 벗어나도 이를 체크하지 않는다  
* 문자열 타입이 따로 없어 char 배열을 대신 사용한다  
* 배열과 포인터의 차이가 비직관적이다  
* unsigned 타입이 섞인 계산에서 음수가 양수가 되버린다 : 부호형(signed 또는 생략)과 무부호(unsigned)형 사이에는 무부호형이 우선권을 가지기 때문에  
                                                      하나라도 무부호형이 섞여 있다면 모든 음수가 양수로 변한다.(절대값이 아닌 mod 연산된 값으로 변함)  
* 함수의 매개변수로 선언된 배열은 배열이 아닌 포인터이다  

---
포인터
---
포인터 덕분에 메모리를 어셈블리어 수준으로 정밀하게 직접 읽고 쓸 수 있지만 그 반작용으로 에러의 90%는 포인터 문제다. **포인터를 버그 없이 쓰려면 적어도 메모리의 정렬 제한 정도는 이해를 하고 있어야 한다.**  
C의 자료형 중에서는 배열, 구조체, 공용체, 함수와 함께 유도형으로 분류된다. 어떤 자료형이든그 뒤어 *(asterisk)를 붙이면 앞의 자룧ㅇ에 대한 포인터가 되며, 중첩해서 포인터에 대한 포인터를 사용하는 것도 가능하다.

C언어에서 포인터는 대체로 다음과 같은 목적으로 쓰인다.
* 참조 : 어떤 객체를 직접 복사해서 전달하느 것이 아니라, 그 객체의 주소값만을 전달하여 처리  
* 메모리에 대한 직접 접근 및 강제 형변환 : 객체는 원래 서로 호환되는 타입으로만 변환될 수있는데,  
 포인터를 이용하면 객체의 메모리 공간에 대해 직접 접근하여, 마치 다른 메모리 타입인 것처럼 다루거나 내부표현 그 자체를 건드릴 수 있음  
 <-이에 대해서는 메모리 정렬 제한(memory alignment)이라는 개념에 대해 반드시 알고 있어야 안전하게 사용 가능함  
 
참조가 상당히 추상적이고 프로그래밍 언어들이 비교적 보편적으로 지원하는 개념이라면,  
메모리에 대한 직접 접근 및 강제 형변환은 하드웨어에 직접 맞닿아 있으면서 한편으로는 다른 프로그래밍 언어에는 잘 지원하지 않거나 혹은 되도록 쓰지 않도록 강제하는 기능이다.  
전자쪽은 비교적 쉬운편이고(대신 이를 응용한 자료구조 및 알고리즘이 머리터짐),  
후자쪽은 하드웨어에 대한 어느 정도의 지식이 필요하기에 비교적 어려운편  


보통의 C언어 입문서에서는 주로 참조 쪽에 집중해서 설명하기에, 입문서의 포인터 부분만 열심히 들여다 본다고 해도 어려운 부분을 이해하는 데에는 큰 도움이 되지 못한다.  
이런 경우에는 컴퓨터 구조를 따로 공부하거나 C언어의 다른 부분을 추가적으로 더 공부하는 것이 바람직하다. 이와 관련된 주요 주제들은 다음과 같으며, 하나같이 어렵고 그양도 방대한 편이다.  

* C언어의 타입 시스템과 암묵적인 형변환  
* 주요 객체의 내부 표현 방식  
* 비트 연산  
* C언어 특유의 문자열과 배열과 포인터의 혼용  
* C언어의 복잡한 선언과 수식을 읽는 방법  
* 하드웨어의 메모리 정렬(memory alignment)  
* 객체의 기억수명(storage duration)  
* 컴퓨터 구조 전반  
 
컴퓨터의 성능이 부족하고 최적화가 시원찮았던 과거의 전통 때문에 C언어의 문화는 저수준의 테크닉을 사용하는 것에 집착하는데,  
컴파일러가 CPU를 더 잘 이해하는 지금에 와서는 오히려 역효과를 부를 수 있으므로 추상적인 동작에 더 집중하는 것이 현명한 방식이다.  
단, 임베디드 분야에서는 저수준의 테크닉이 여전히 절대적으로 중요하다.


---
주요 오개념 : 배열과 포인터 사이의 관계
---
배열 타입을 갖는 수식은 자동 변환되어, 그 배열의 첫번째 원소를 가리키는 포인터 주소값을 반환한다.  
이 결과 값은 Lvalue( a = b; 는 a 주소에 b의 값을 할당 하라는 뜻, Lvalue는 객체를 식별하는 메모리 위치를 나타냄)이 아니다.  
여기에는 아래의 3가지 예외상황이 존재한다.  

* 예외1 : sizeof 연산자의 피연산자로 쓰인경우 (sizeof(arr))  
* 예외2 : & 연산자의 피연산자로 쓰인경우 (&arr)  
* 예외3 : char형 배열의 초기화에 쓰이는 문자열 상수인 경우 (char str[] = "hello")  
* 문자형 배열을 초기화할 때는 반드시 문자열 상수로만 해야된다는 뜻  
 

 
함수의 매개변수 선언부에서는 배열이 포인터로 자동 변환되는 비슷한 규칙이 적용된다.  
함수 선언시 매개변수로 배열 타입이 쓰일 경우, 이것은 qualified pointer 타입으로 변환된다. 이때 붙이는 type qualifier는 [ ] 안에 적힌 것을 사용한다.  
이 규칙으로 인해서, C에서는 함수의 매개변수로 배열을 직접 복사해서 넘길 수 없다. 다르게 표현하자면, 함수의 매개변수로 배열을 사용할 수 없다.  
배열보다 훨씬 더 복잡한 객체인 구조체도 함수의 매개변수로 사용할 수 있는 것을 고려하면, 이 규칙은 상당히 독특하다고 할 수 있다.  

함수 호출과 관련하여, 배열 타입이 포인터 주소값으로 변환되는 규칙과 유사한, 기묘한 규칙이 한가지 더 존재한다.  
C언어에서 모든 함수 타입은 함수 그 자체에 대한 포인터 주소값으로 자동 변환된다.
(배열의 경우와 비슷하게, 이 규칙의 예외는 sizeof, &의 피연산자로 쓰일 경우이다.) 그리고 함수호출은 함수 타입이 아니라 함수에 대한 포인터 주소값을 통해 이루어진다.  


---
주요 오개념 : 포인터의 크기 및 상호 변환 관계
---



---
주요 오개념 : 스택(stack)과 힙(heap)
---



---
문법 상 주의점
---
* short 자료형을 특별한 이유 없이 사용한다 : 32비트 아키텍처 상의 CPU는 자료형의 팩/언팩작업 때문에 short 자료형의 퍼포먼스가 int형 보다 낮으며 오버플로 위함만 높인다.
 


---
C언어 관련 책
---
1. Kernighan의 C언어 프로그래밍 : C언어 바이블, 숨은 함정들을 잘 짚어주는 책이지만 연식이 오래되어 초창기 유행이나 트리 정도만 남아 있고  
                                최신의 변화 등을 반영하지 못하고 있기때문에 복습 차원으로 보는 것이 좋다.  
2. C언어 펀더멘탈(전웅) : C99 표준을 제대로 설명하는 몇 안되는 중급서.  
3. 혼자 공부하는 C언어  
