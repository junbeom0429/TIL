>## Chap2. 객체지향 프로그래밍과 스위프트  
>9. 구조체와 클래스  
>10. 프로퍼티와 메서드  
>11. 인스턴스 생성 및 소멸  
>12. 접근제어  

---
# 구조체와 클래스
---

```swift
/* 구조체의 인스턴스 생성 및 사용 */

struct 구조체이름 {
  var 프로퍼티1: Int
  var 프로퍼티2: Int
}

var 구조체인스턴스이름: 구조체이름 = 구조체이름(프로퍼티1: 0, 프로퍼티2: 1)  
//구조체를 정의한다는 것은 새로운 타입을 생성해주는 것과 마찬가지이므로 타입입력에 구조체이름을 넣어주면 된다
구조체인스턴스이름.프로퍼티1 = 2  // 변수(var)로 생성했기 때문에 변경가능
```
---
```swift
/* 클래스의 인스턴스 생성 및 사용*/

class 클래스이름: 부모클래스이름 {
  var 프로퍼티1: Float = 0.0
  var 프로퍼티2: Int = 1
}

let 클래스인스턴스이름: 클래스이름 = 클래스이름()
클래스인스턴스이름.프로퍼티1 = 12.3  
// 상수(let)으로 생성했음에도 클래스의 인스턴스는 참조타입이므로 내부 프로퍼티값을 변경할 수 있다
```
---
### 클래스 인스턴스의 소멸  
---

클래스의 인스턴스는 참조타입으므로 더는 참조할 필요가 없을 때 메모리에서 해제됩니다  
이 과정을 소멸이라고 하는데 소멸되기 직전 deinit라는 메서드가 호출됩니다  

**deinit (Deinitializer)**
* 클래스당 하나만 구현가능  
* 매개변수와 반환값 없음  
* 매개변수를 위한 소괄호()도 기입하지 않음  

```swift
class 클래스이름: 부모클래스이름 {
  var 프로퍼티1: String = " "

  deinit {
    //메모리에서 해제되기 직전에 처리할 코드를 넣어줍니다
  }
}
```

---
### 구조체와 클래스의 차이  
---

**핵심 차이점**  
* 구조체의 인스턴스는 값 타입 vs. 클래스의 인스턴스는 참조 타입  

**이에 파생되는 구체적인 차이점**  
* 구조체는 상속할 수 없다  
* 타입캐스팅은 클래스의 인스턴스에만 허용  
* 디이니셜라이저는 클래스의 인스턴스에만 활용  
* 참조횟수계산(Reference Counting)은 클래스의 인스턴스에만 적용  

>**값 vs 참조**  
>  값타임은 데이터를 전달인자로 전달하면 복사되어 새로운 인스턴스 생성  
>  참조타입은 포인터(Pointer)처럼 주소값을 주어 기존의 인스턴스를 참조 전달  

